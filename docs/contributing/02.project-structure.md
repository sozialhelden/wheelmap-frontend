# Project structure

## Contents

1. [Folder structure](#1-folder-structure)
2. [Architecture](#2-architecture)
   1. [Global app state](#1-global-app-state)

## 1. Folder structure

_An example overview of how the project is structured:_

```text
.
â”œâ”€â”€ ðŸ“ docs/
â”œâ”€â”€ ðŸ“ public/
â”œâ”€â”€ ðŸ“ tests/
â”‚   â””â”€â”€ ðŸ“„ mapping-event-flow.e2e-spec.ts
â””â”€â”€ ðŸ“ src/
    â”œâ”€â”€ ðŸ“ components/
    â”‚   â””â”€â”€ ðŸ“ Button/
    â”‚       â”œâ”€â”€ ðŸ“„ Button.tsx
    â”‚       â””â”€â”€ ðŸ“ tests/
    â”‚           â”œâ”€â”€ ðŸ“„ Button.spec.ts
    â”‚           â””â”€â”€ ðŸ“„ Button.e2e-spec.ts
    â”œâ”€â”€ ðŸ“ utils/
    â”‚   â””â”€â”€ ðŸ“ localization/
    â”‚       â”œâ”€â”€ ðŸ“„ i18n-parser.ts
    â”‚       â””â”€â”€ ðŸ“ tests/
    â”‚           â””â”€â”€ ðŸ“„ i18n-parser.spec.ts
    â”œâ”€â”€ ðŸ“ hooks/
    â”œâ”€â”€ ðŸ“ modules/
    â”‚   â””â”€â”€ ðŸ“ categories/
    â”‚       â”œâ”€â”€ ðŸ“„ categories.ts
    â”‚       â”œâ”€â”€ ðŸ“ components/
    â”‚       â”‚   â””â”€â”€ ðŸ“„ CategoryFilter.tsx
    â”‚       â”œâ”€â”€ ðŸ“ utils/
    â”‚       â”‚   â”œâ”€â”€ ðŸ“„ category-fetcher.ts
    â”‚       â”‚   â””â”€â”€ ðŸ“„ category-cache.ts
    â”‚       â”œâ”€â”€ ðŸ“ hooks/
    â”‚       â”‚   â””â”€â”€ ðŸ“„ useCategories.ts
    â”‚       â”œâ”€â”€ ðŸ“ tests/
    â”‚       â”‚   â”œâ”€â”€ ðŸ“„ category-filter.e2e-spec.ts
    â”‚       â”‚   â””â”€â”€ ðŸ“„ category-cache.spec.ts
    â”‚       â””â”€â”€ ðŸ“ types/
    â”‚           â””â”€â”€ ðŸ“„  ACCategory.ts
    â””â”€â”€ ðŸ“ app/
        â””â”€â”€ ðŸ“ [slug]/
            â”œâ”€â”€ ðŸ“„ page.tsx
            â”œâ”€â”€ ðŸ“ _components/
            â”œâ”€â”€ ðŸ“ _utils/
            â”œâ”€â”€ ðŸ“ _hooks/
            â”œâ”€â”€ ðŸ“ _tests/
            â””â”€â”€ ðŸ“ _types/
```

> [!IMPORTANT]
> Our goal is to keep logic at the level where it's utilized and tests adjacent to the tested logic. This approach promotes maintainability, scalability, and reusability.

### naming pattern

Starting from the root level, our project has several key folders:

*   `docs/`: For documentation and related files
*   `public/`: Holds static assets that are served directly by the web server
*   `tests/`: Contains overarching tests, e.g. for user-flows spanning multiple pages or the entire application
*   `src/`: The primary location of source code

Upon further exploration, we notice a recurring folder pattern:

*   `components/`: For reusable UI components
*   `utils/`: Houses utility functions
*   `hooks/`: Custom hooks that either use state and/or other hooks
*   `types/`: Defines data types and interfaces
*   `tests/`: Tests for the corresponding scope

### pages

For components, hooks, types, utility functions, or tests only used within a single page, place them directly next to that page. For instance:

If we have a `./src/app/upload/index.ts` for uploading images, related components, hooks, types, and functions should reside in the corresponding subfolders (`_components`, `_hooks`, `_types`, `_tests`, and `_utils`) within `app/upload`.

### modules

When logic spans multiple pages but is tied to a specific feature or domain, encapsulate it within the `./src/modules/` directory. For example:

In our project, categories are used for describing and filtering places across different pages. We place the related components, functions, hooks, tests, and types in `./src/modules/categories`.

### shared

For elements shared across multiple modules or pages but lacking a distinct domain connection, store them at the root level of `src`, either in `components/`, `utils/`, `hooks/`, or `types/`. This includes for example:

* Interface components, e.g. a Button
* Generic utility functions, e.g. for strings or dates
* Generic hooks, e.g. that manage global module-independent state

## 2. Architecture

### 1. Global app state

The app has a global state that is entirely controlled by query parameters. E.g. the current selection of the need picker, the selected category to filter places by or the map bounds. The idea is to allow people to share links to the app to a certain state.

The app-state can be configured in `src/modules/app-state/app-state.ts`. The implementation also allows complex deeply nested objects as state as well as persisting parts of it to local storage and restoring it when no query parameters are found. As every state is different, you need to bring your own parser that validates and sanitizes the contents, in case you want to add state to the global one.
